---
import BaseLayout from '../../layouts/BaseLayout.astro';
import HiddenGrammarNav from '../../components/HiddenGrammarNav.astro';

const principles = await import('../../data/hg-principles.json');
const roots = await import('../../data/hg-roots.json');
const modes = await import('../../data/hg-modes.json');
---

<BaseLayout
  title="AI Art Analysis - Hidden Grammar"
>
  <div class="hg-layout">
    <HiddenGrammarNav />
    <div class="hg-content">
      <div class="page-container">
        <div class="content-wrapper">
      <header class="page-header">
        <h1>Hidden Grammar AI Analysis</h1>
        <p class="subtitle">Upload artwork and receive instant AI-powered analysis using the Hidden Grammar framework</p>
      </header>

      <main class="analysis-container">
        <!-- Analysis Form -->
        <div id="analysisForm" class="analysis-form">

          <!-- Section 0: Image Upload & Metadata -->
          <section class="form-section">
            <div class="section-header">
              <span class="section-number">1</span>
              <h2>Upload Artwork</h2>
            </div>

            <!-- Image Upload -->
            <div class="upload-container">
              <div id="uploadArea" class="upload-area">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <polyline points="17 8 12 3 7 8"></polyline>
                  <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                <p><strong>Click to upload</strong> or drag & drop</p>
                <p class="upload-hint">JPG, PNG, WebP (large images auto-optimized)</p>
                <input type="file" id="imageInput" accept="image/*" hidden>
              </div>

              <div id="imagePreviewContainer" class="image-preview-container" style="display: none;">
                <img id="imagePreview" alt="Uploaded artwork">
                <button type="button" id="removeImage" class="btn-remove">Remove Image</button>
              </div>
            </div>

            <!-- Basic Metadata (Optional) -->
            <div class="metadata-grid">
              <div class="form-group">
                <label for="artworkTitle">Artwork Title <span class="optional">(optional)</span></label>
                <input type="text" id="artworkTitle" placeholder="e.g., Starry Night">
              </div>

              <div class="form-group">
                <label for="artistName">Artist <span class="optional">(optional)</span></label>
                <input type="text" id="artistName" placeholder="e.g., Vincent van Gogh">
              </div>

              <div class="form-group">
                <label for="yearCreated">Year <span class="optional">(optional)</span></label>
                <input type="text" id="yearCreated" placeholder="e.g., 1889">
              </div>

              <div class="form-group">
                <label for="medium">Medium <span class="optional">(optional)</span></label>
                <input type="text" id="medium" placeholder="e.g., Oil on canvas">
              </div>

              <div class="form-group">
                <label for="dimensions">Dimensions <span class="optional">(optional, in inches)</span></label>
                <input type="text" id="dimensions" placeholder="e.g., 24 x 36 or 18 x 24 x 2">
              </div>
            </div>
          </section>

          <!-- Section 2: Analysis Configuration -->
          <section class="form-section">
            <div class="section-header">
              <span class="section-number">2</span>
              <h2>Configure Analysis</h2>
            </div>

            <!-- Custom Prompt Input -->
            <div class="custom-prompt-section">
              <div class="subsection-header">
                <h3>Custom Analysis Prompt</h3>
                <p class="subsection-description">Write your own analysis instructions or questions for the AI</p>
              </div>
              
              <div class="form-group">
                <label for="customPrompt">
                  Custom Prompt <span class="optional">(optional - leave blank to use a pre-formatted mode below)</span>
                </label>
                <textarea 
                  id="customPrompt" 
                  rows="6"
                  placeholder="Example: Focus on the color palette and how it creates mood. Explain the composition choices and their effect on the viewer's attention. Compare this work to Impressionist techniques..."
                ></textarea>
                <p class="field-hint">
                  When you provide a custom prompt, the AI will use your instructions instead of the pre-formatted modes below.
                  The Hidden Grammar framework data (11 Roots, 46 Principles) will still be available to the AI.
                </p>
              </div>
            </div>

            <!-- Pre-formatted Analysis Modes -->
            <div class="preformatted-modes-section">
              <div class="subsection-header">
                <h3>Pre-formatted Analysis Modes</h3>
                <p class="subsection-description">Or choose a structured analysis template</p>
              </div>

              <div class="mode-selector">
                {modes.modes.map((mode) => (
                  <label class="mode-card">
                    <input type="radio" name="analysisMode" value={mode.id}>
                    <div class="mode-content">
                      <h3>{mode.name}</h3>
                      <p class="mode-phase">{mode.phase}</p>
                      <p class="mode-description">{mode.description}</p>
                    </div>
                  </label>
                ))}
              </div>
            </div>
          </section>

          <!-- Action Buttons -->
          <div class="form-actions">
            <button type="button" class="btn-primary" id="analyzeBtn" disabled>
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m8 3 4 8 5-5 5 15H2L8 3z"></path>
              </svg>
              Analyze with AI
            </button>
          </div>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="loading-state" style="display: none;">
          <div class="loading-spinner"></div>
          <h2>Analyzing artwork...</h2>
          <p>AI is examining the visual grammar and generating your analysis report</p>
        </div>

        <!-- Results Panel -->
        <div id="resultsPanel" class="results-panel" style="display: none;">
          <div class="results-header">
            <h2>Analysis Results</h2>
            <div class="results-actions">
              <button class="btn-secondary" id="backToForm">← New Analysis</button>
              <button class="btn-secondary" id="exportMarkdown">Export Markdown</button>
              <button class="btn-secondary" id="exportJSON">Export JSON</button>
              <button class="btn-secondary" id="exportPDF">Export PDF</button>
              <button class="btn-secondary" id="copyToClipboard">Copy to Clipboard</button>
            </div>
          </div>
          <div id="resultsContent" class="results-content"></div>
        </div>
      </main>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script>
  // Image Upload Handling
  const uploadArea = document.getElementById('uploadArea');
  const imageInput = document.getElementById('imageInput');
  const imagePreviewContainer = document.getElementById('imagePreviewContainer');
  const imagePreview = document.getElementById('imagePreview');
  const removeImage = document.getElementById('removeImage');
  const analyzeBtn = document.getElementById('analyzeBtn');

  let uploadedImageData: string | null = null;

  uploadArea?.addEventListener('click', () => imageInput?.click());

  uploadArea?.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  });

  uploadArea?.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
  });

  uploadArea?.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    const file = e.dataTransfer?.files[0];
    if (file && file.type.startsWith('image/')) {
      handleImageUpload(file);
    }
  });

  imageInput?.addEventListener('change', (e) => {
    const file = (e.target as HTMLInputElement).files?.[0];
    if (file) {
      handleImageUpload(file);
    }
  });

  removeImage?.addEventListener('click', () => {
    if (imageInput) (imageInput as HTMLInputElement).value = '';
    if (imagePreview) (imagePreview as HTMLImageElement).src = '';
    if (uploadArea) uploadArea.style.display = 'flex';
    if (imagePreviewContainer) imagePreviewContainer.style.display = 'none';
    uploadedImageData = null;
    if (analyzeBtn) (analyzeBtn as HTMLButtonElement).disabled = true;
  });

  function handleImageUpload(file: File) {
    const reader = new FileReader();
    reader.onload = (e) => {
      if (!e.target?.result) return;
      
      const result = e.target.result as string;
      
      // Load image to check/resize it
      const img = new Image();
      img.onload = () => {
        // Calculate current size (base64 to bytes approximation)
        const currentSize = result.length * 0.75;
        const maxSize = 4 * 1024 * 1024; // Target 4MB to stay well under 5MB API limit
        
        let finalResult = result;
        let wasResized = false;
        
        // Check if resizing needed (either size or dimensions)
        if (currentSize > maxSize || img.width > 2048 || img.height > 2048) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          if (!ctx) {
            alert('Canvas not supported. Please try a different browser.');
            return;
          }
          
          // Calculate new dimensions (max 2048px on longest side)
          let width = img.width;
          let height = img.height;
          const maxDimension = 2048;
          
          if (width > maxDimension || height > maxDimension) {
            if (width > height) {
              height = (height / width) * maxDimension;
              width = maxDimension;
            } else {
              width = (width / height) * maxDimension;
              height = maxDimension;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          
          // Try different quality levels to get under target size
          let quality = 0.9;
          let compressedResult = canvas.toDataURL('image/jpeg', quality);
          
          while (compressedResult.length * 0.75 > maxSize && quality > 0.3) {
            quality -= 0.1;
            compressedResult = canvas.toDataURL('image/jpeg', quality);
          }
          
          finalResult = compressedResult;
          wasResized = true;
          
          console.log(`Image automatically resized: ${img.width}x${img.height} → ${Math.round(width)}x${Math.round(height)} @ ${Math.round(quality * 100)}% quality`);
          console.log(`Size: ${(currentSize / 1024 / 1024).toFixed(2)}MB → ${(compressedResult.length * 0.75 / 1024 / 1024).toFixed(2)}MB`);
        }
        
        // Check final size
        const finalSize = finalResult.length * 0.75;
        if (finalSize > 5 * 1024 * 1024) {
          alert('Image is still too large after compression. Please use a smaller image or reduce its resolution.');
          return;
        }
        
        // Display and store the processed image
        if (imagePreview) (imagePreview as HTMLImageElement).src = finalResult;
        uploadedImageData = finalResult;
        if (uploadArea) uploadArea.style.display = 'none';
        if (imagePreviewContainer) imagePreviewContainer.style.display = 'block';
        if (analyzeBtn) (analyzeBtn as HTMLButtonElement).disabled = false;
        
        if (wasResized) {
          // Show brief notification
          const notification = document.createElement('div');
          notification.textContent = '✓ Image automatically optimized for analysis';
          notification.style.cssText = 'position:fixed;top:20px;right:20px;background:#7c3aed;color:white;padding:12px 20px;border-radius:8px;z-index:10000;font-family:var(--font-body);box-shadow:0 4px 12px rgba(0,0,0,0.15);';
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 3000);
        }
      };
      
      img.onerror = () => {
        alert('Failed to load image. Please try a different file.');
      };
      
      img.src = result;
    };
    reader.readAsDataURL(file);
  }

  // Custom Prompt & Mode Selection Interaction
  const customPromptTextarea = document.getElementById('customPrompt') as HTMLTextAreaElement;
  const modeRadios = document.querySelectorAll('input[name="analysisMode"]') as NodeListOf<HTMLInputElement>;
  const customPromptSection = document.querySelector('.custom-prompt-section') as HTMLElement;
  const modesSection = document.querySelector('.preformatted-modes-section') as HTMLElement;

  // When user types in custom prompt, deselect all mode radios and dim modes section
  customPromptTextarea?.addEventListener('input', () => {
    const hasCustomPrompt = customPromptTextarea.value.trim().length > 0;
    if (hasCustomPrompt) {
      modeRadios.forEach(radio => {
        radio.checked = false;
      });
      modesSection?.classList.add('inactive');
      customPromptSection?.classList.remove('inactive');
    } else {
      // If custom prompt is cleared, re-enable modes section
      modesSection?.classList.remove('inactive');
    }
  });

  // When user selects a mode, clear the custom prompt and dim custom prompt section
  modeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      if (radio.checked) {
        if (customPromptTextarea) {
          customPromptTextarea.value = '';
        }
        customPromptSection?.classList.add('inactive');
        modesSection?.classList.remove('inactive');
      }
    });
  });

  // Analyze Button Handler
  const loadingState = document.getElementById('loadingState');
  const resultsPanel = document.getElementById('resultsPanel');
  const analysisForm = document.getElementById('analysisForm');
  const resultsContent = document.getElementById('resultsContent');
  const backToForm = document.getElementById('backToForm');
  
  // Store analysis data for export/copy
  let rawMarkdownContent = '';
  let analysisMetadata = {
    title: '',
    artist: '',
    year: '',
    medium: '',
    dimensions: '',
    mode: '',
    customPrompt: '',
    timestamp: ''
  };

  analyzeBtn?.addEventListener('click', async () => {
    if (!uploadedImageData) {
      alert('Please upload an image first');
      return;
    }

    // Get form data
    const title = (document.getElementById('artworkTitle') as HTMLInputElement)?.value || 'Untitled';
    const artist = (document.getElementById('artistName') as HTMLInputElement)?.value || 'Unknown Artist';
    const year = (document.getElementById('yearCreated') as HTMLInputElement)?.value;
    const medium = (document.getElementById('medium') as HTMLInputElement)?.value;
    const dimensions = (document.getElementById('dimensions') as HTMLInputElement)?.value;
    const customPrompt = (document.getElementById('customPrompt') as HTMLTextAreaElement)?.value || '';
    const selectedModeRadio = document.querySelector('input[name="analysisMode"]:checked') as HTMLInputElement;
    const mode = selectedModeRadio?.value || 'strategic';
    
    // Validate that either custom prompt or mode is selected
    if (!customPrompt.trim() && !selectedModeRadio) {
      alert('Please either enter a custom prompt or select a pre-formatted analysis mode');
      if (loadingState) loadingState.style.display = 'none';
      if (analysisForm) analysisForm.style.display = 'block';
      return;
    }

    // Show loading state
    if (analysisForm) analysisForm.style.display = 'none';
    if (loadingState) loadingState.style.display = 'flex';

    try {
      // Call API endpoint to analyze image
      const response = await fetch('/api/analyze-artwork', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          image: uploadedImageData,
          title,
          artist,
          year,
          medium,
          dimensions,
          mode,
          customPrompt,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        console.error('API Error:', result);
        alert(`Analysis failed: ${result.details || result.error}\n\nAPI Key Present: ${result.apiKeyPresent}\n\nCheck console for more details.`);
        if (loadingState) loadingState.style.display = 'none';
        if (analysisForm) analysisForm.style.display = 'block';
        return;
      }

      // Display results
      if (resultsContent) {
        resultsContent.innerHTML = result.analysis;
      }
      
      // Store raw markdown and metadata for export/copy
      rawMarkdownContent = result.raw || '';
      
      // Get mode name from the label associated with selected radio
      let modeName = mode;
      if (selectedModeRadio) {
        const modeLabel = selectedModeRadio.closest('.mode-card')?.querySelector('h3');
        if (modeLabel) {
          modeName = modeLabel.textContent || mode;
        }
      }
      
      analysisMetadata = {
        title,
        artist,
        year,
        medium,
        dimensions,
        mode: modeName,
        customPrompt,
        timestamp: new Date().toISOString()
      };
      
      if (loadingState) loadingState.style.display = 'none';
      if (resultsPanel) resultsPanel.style.display = 'block';
      window.scrollTo(0, 0);

    } catch (error) {
      console.error('Analysis error:', error);
      alert('Failed to analyze artwork. Please try again.\n\nCheck console for more details.');
      if (loadingState) loadingState.style.display = 'none';
      if (analysisForm) analysisForm.style.display = 'block';
    }
  });

  backToForm?.addEventListener('click', () => {
    // Reset form state for new analysis
    if (analysisForm) analysisForm.style.display = 'block';
    if (resultsPanel) resultsPanel.style.display = 'none';
    
    // Clear custom prompt
    if (customPromptTextarea) {
      customPromptTextarea.value = '';
    }
    
    // Deselect all mode radios
    modeRadios.forEach(radio => {
      radio.checked = false;
    });
    
    // Remove inactive classes from both sections so they're both accessible
    customPromptSection?.classList.remove('inactive');
    modesSection?.classList.remove('inactive');
    
    window.scrollTo(0, 0);
  });

  // Export functionality
  const exportBtn = document.getElementById('exportMarkdown');
  const copyBtn = document.getElementById('copyToClipboard');

  exportBtn?.addEventListener('click', () => {
    if (!rawMarkdownContent) {
      alert('No analysis to export. Please run an analysis first.');
      return;
    }
    const blob = new Blob([rawMarkdownContent], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'hidden-grammar-analysis.md';
    a.click();
    URL.revokeObjectURL(url);
  });

  copyBtn?.addEventListener('click', () => {
    if (!rawMarkdownContent) {
      alert('No analysis to copy. Please run an analysis first.');
      return;
    }
    navigator.clipboard.writeText(rawMarkdownContent).then(() => {
      alert('Analysis copied to clipboard!');
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy to clipboard. Please try again.');
    });
  });

  // Export to JSON
  const exportJSONBtn = document.getElementById('exportJSON');
  exportJSONBtn?.addEventListener('click', () => {
    if (!rawMarkdownContent) {
      alert('No analysis to export. Please run an analysis first.');
      return;
    }
    
    const jsonData = {
      metadata: analysisMetadata,
      analysis: {
        markdown: rawMarkdownContent,
        html: resultsContent?.innerHTML || ''
      },
      exportedAt: new Date().toISOString()
    };
    
    const jsonString = JSON.stringify(jsonData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `hidden-grammar-analysis-${analysisMetadata.title.replace(/\s+/g, '-').toLowerCase() || 'artwork'}.json`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // Export to PDF (downloadable using html2pdf)
  const exportPDFBtn = document.getElementById('exportPDF');
  exportPDFBtn?.addEventListener('click', async () => {
    if (!rawMarkdownContent) {
      alert('No analysis to export. Please run an analysis first.');
      return;
    }
    
    // Check if html2pdf is available
    if (typeof (window as any).html2pdf === 'undefined') {
      console.error('html2pdf library not loaded');
      alert('PDF library not loaded. Please refresh the page and try again.');
      return;
    }
    
    // Show loading state
    const originalText = exportPDFBtn?.textContent;
    if (exportPDFBtn) exportPDFBtn.textContent = 'Generating PDF...';
    if (exportPDFBtn) (exportPDFBtn as HTMLButtonElement).disabled = true;
    
    console.log('Starting PDF generation...');
    
    try {
      // Create a temporary container for PDF content (isolated from Astro dev toolbar)
      const tempContainer = document.createElement('div');
      tempContainer.style.position = 'absolute';
      tempContainer.style.left = '-9999px';
      tempContainer.style.width = '8.5in'; // Letter width
      tempContainer.style.isolation = 'isolate'; // Isolate from other elements
      tempContainer.className = 'pdf-export-temp'; // Mark for exclusion
      
      // Get the results content and apply inline styles
      const resultsClone = resultsContent?.cloneNode(true) as HTMLElement;
      
      // Remove any Astro dev toolbar elements from the clone
      if (resultsClone) {
        resultsClone.querySelectorAll('astro-dev-toolbar, astro-island, [data-astro-dev-toolbar]').forEach(el => el.remove());
      }
      
      // Apply styles to all elements in the cloned content
      if (resultsClone) {
        // Style all headings
        resultsClone.querySelectorAll('h1').forEach((el: any) => {
          el.style.cssText = 'color: #7c3aed; font-size: 24px; margin: 30px 0 15px 0; border-bottom: 3px solid #7c3aed; padding-bottom: 10px; page-break-after: avoid;';
        });
        resultsClone.querySelectorAll('h2').forEach((el: any) => {
          el.style.cssText = 'color: #7c3aed; font-size: 20px; margin: 25px 0 12px 0; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px; page-break-after: avoid;';
        });
        resultsClone.querySelectorAll('h3').forEach((el: any) => {
          el.style.cssText = 'color: #7c3aed; font-size: 16px; margin: 20px 0 10px 0; page-break-after: avoid;';
        });
        resultsClone.querySelectorAll('h4').forEach((el: any) => {
          el.style.cssText = 'color: #7c3aed; font-size: 14px; margin: 15px 0 8px 0; page-break-after: avoid;';
        });
        
        // Style paragraphs
        resultsClone.querySelectorAll('p').forEach((el: any) => {
          el.style.cssText = 'margin: 12px 0; line-height: 1.6;';
        });
        
        // Style lists
        resultsClone.querySelectorAll('ul, ol').forEach((el: any) => {
          el.style.cssText = 'margin: 12px 0; padding-left: 30px;';
        });
        resultsClone.querySelectorAll('li').forEach((el: any) => {
          el.style.cssText = 'margin: 6px 0; line-height: 1.6;';
        });
        
        // Style tables
        resultsClone.querySelectorAll('table').forEach((el: any) => {
          el.style.cssText = 'width: 100%; border-collapse: collapse; margin: 20px 0; page-break-inside: avoid;';
        });
        resultsClone.querySelectorAll('th').forEach((el: any) => {
          el.style.cssText = 'background-color: #f3f4f6; border: 1px solid #d1d5db; padding: 8px 12px; text-align: left; font-weight: 600;';
        });
        resultsClone.querySelectorAll('td').forEach((el: any) => {
          el.style.cssText = 'border: 1px solid #d1d5db; padding: 8px 12px; text-align: left;';
        });
        
        // Style strong/bold
        resultsClone.querySelectorAll('strong').forEach((el: any) => {
          el.style.cssText = 'color: #374151; font-weight: 600;';
        });
      }
      
      tempContainer.innerHTML = `
        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #1a1a1a; padding: 20px;">
          <div style="background: #f9fafb; padding: 15px; border-left: 4px solid #7c3aed; margin-bottom: 30px;">
            <h1 style="color: #7c3aed; border-bottom: 3px solid #7c3aed; padding-bottom: 10px; margin: 0 0 20px 0; font-size: 24px;">Hidden Grammar Analysis</h1>
            ${uploadedImageData ? `<img src="${uploadedImageData}" alt="Artwork" style="width: 144px; height: 144px; object-fit: contain; display: block; margin: 15px 0 20px 0; border: 1px solid #d1d5db; border-radius: 4px;">` : ''}
            <p style="margin: 5px 0;"><strong>Artwork:</strong> ${analysisMetadata.title}</p>
            <p style="margin: 5px 0;"><strong>Artist:</strong> ${analysisMetadata.artist}</p>
            ${analysisMetadata.year ? `<p style="margin: 5px 0;"><strong>Year:</strong> ${analysisMetadata.year}</p>` : ''}
            ${analysisMetadata.medium ? `<p style="margin: 5px 0;"><strong>Medium:</strong> ${analysisMetadata.medium}</p>` : ''}
            ${analysisMetadata.dimensions ? `<p style="margin: 5px 0;"><strong>Dimensions:</strong> ${analysisMetadata.dimensions}</p>` : ''}
            <p style="margin: 5px 0;"><strong>Analysis Mode:</strong> ${analysisMetadata.mode}</p>
            <p style="margin: 5px 0;"><strong>Analysis Date:</strong> ${new Date(analysisMetadata.timestamp).toLocaleString()}</p>
          </div>
        </div>
      `;
      
      // Append the styled results content
      if (resultsClone) {
        tempContainer.firstElementChild?.appendChild(resultsClone);
      }
      
      document.body.appendChild(tempContainer);
      console.log('Container added to body');
      console.log('Container HTML length:', tempContainer.innerHTML.length);
      
      // Configure PDF options
      const opt = {
        margin: [0.5, 0.5, 0.5, 0.5], // inches
        filename: `hidden-grammar-analysis-${analysisMetadata.title.replace(/\s+/g, '-').toLowerCase() || 'artwork'}.pdf`,
        image: { type: 'jpeg', quality: 0.95 },
        html2canvas: { 
          scale: 2, 
          useCORS: true, 
          logging: true,
          ignoreElements: (element: HTMLElement) => {
            // Ignore Astro dev toolbar and other non-content elements
            return element.tagName === 'ASTRO-DEV-TOOLBAR' || 
                   element.tagName === 'ASTRO-ISLAND' ||
                   element.hasAttribute('data-astro-dev-toolbar') ||
                   element.classList.contains('astro-dev-toolbar');
          }
        },
        jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
      };
      
      console.log('PDF options:', opt);
      
      // Generate and download PDF
      console.log('Calling html2pdf...');
      await (window as any).html2pdf().set(opt).from(tempContainer).save();
      console.log('PDF generated successfully');
      
      // Clean up
      document.body.removeChild(tempContainer);
      
      if (exportPDFBtn) exportPDFBtn.textContent = originalText || 'Export PDF';
      if (exportPDFBtn) (exportPDFBtn as HTMLButtonElement).disabled = false;
      
    } catch (error) {
      console.error('PDF generation error:', error);
      alert('Failed to generate PDF. Please try again.');
      if (exportPDFBtn) exportPDFBtn.textContent = originalText || 'Export PDF';
      if (exportPDFBtn) (exportPDFBtn as HTMLButtonElement).disabled = false;
    }
  });
</script>

<style>
  /* Box-sizing for all Hidden Grammar elements */
  .hg-layout *,
  .hg-layout *::before,
  .hg-layout *::after {
    box-sizing: border-box;
  }

  .hg-layout {
    display: flex;
    min-height: calc(100vh - 200px);
  }

  .hg-content {
    flex: 1;
    overflow-y: auto;
  }

  @media (max-width: 1023px) {
    .hg-layout {
      flex-direction: column;
    }
  }

  .page-container {
    min-height: 100vh;
    background: var(--color-gray-1);
    padding: clamp(1rem, 5vw, 3rem) clamp(1rem, 4vw, 2rem);
  }

  .content-wrapper {
    max-width: 1200px;
    margin: 0 auto;
  }

  .page-header {
    text-align: center;
    margin-bottom: clamp(2rem, 5vw, 3rem);
  }

  .page-header h1 {
    font-family: var(--font-display);
    font-size: clamp(2rem, 5vw, 2.5rem);
    color: var(--color-purple);
    margin-bottom: clamp(0.5rem, 1.5vw, 0.75rem);
  }

  .subtitle {
    font-size: clamp(1rem, 2vw, 1.125rem);
    color: var(--color-gray-7);
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
    padding: 0 clamp(1rem, 3vw, 2rem);
  }

  .analysis-container {
    background: var(--color-white);
    border-radius: 12px;
    padding: clamp(1.5rem, 4vw, 3rem);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .form-section {
    margin-bottom: clamp(2rem, 5vw, 3rem);
    padding-bottom: clamp(1.5rem, 4vw, 3rem);
    border-bottom: 2px solid var(--color-gray-2);
  }

  .form-section:last-of-type {
    border-bottom: none;
  }

  .section-header {
    display: flex;
    align-items: center;
    gap: clamp(0.75rem, 2vw, 1rem);
    margin-bottom: clamp(1rem, 3vw, 1.5rem);
  }

  .section-number {
    display: flex;
    align-items: center;
    justify-content: center;
    width: clamp(36px, 8vw, 40px);
    height: clamp(36px, 8vw, 40px);
    flex-shrink: 0;
    background: var(--color-purple);
    color: var(--color-white);
    border-radius: 50%;
    font-weight: 700;
    font-size: clamp(1rem, 2.5vw, 1.125rem);
  }

  .section-header h2 {
    font-family: var(--font-heading);
    font-size: clamp(1.5rem, 3.5vw, 1.75rem);
    color: var(--color-gray-9);
    margin: 0;
  }

  .section-description {
    color: var(--color-gray-6);
    font-size: clamp(0.875rem, 2vw, 1rem);
    line-height: 1.6;
    margin-bottom: clamp(1rem, 3vw, 1.5rem);
  }

  /* Subsections */
  .custom-prompt-section,
  .preformatted-modes-section {
    margin-bottom: clamp(2rem, 5vw, 3rem);
    transition: opacity 0.2s ease;
  }

  .custom-prompt-section.inactive,
  .preformatted-modes-section.inactive {
    opacity: 0.4;
    pointer-events: none;
  }

  .subsection-header {
    margin-bottom: clamp(1rem, 3vw, 1.5rem);
  }

  .subsection-header h3 {
    font-family: var(--font-heading);
    font-size: clamp(1.25rem, 3vw, 1.5rem);
    color: var(--color-purple);
    margin: 0 0 clamp(0.375rem, 1vw, 0.5rem) 0;
  }

  .subsection-description {
    color: var(--color-gray-6);
    font-size: clamp(0.875rem, 2vw, 1rem);
    line-height: 1.6;
    margin: 0;
  }

  .field-hint {
    font-size: clamp(0.8125rem, 1.8vw, 0.875rem);
    color: var(--color-gray-5);
    line-height: 1.5;
    margin-top: clamp(0.375rem, 1vw, 0.5rem);
    font-style: italic;
  }

  /* Upload Area */
  .upload-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: clamp(2rem, 5vw, 3rem);
    border: 3px dashed var(--color-gray-4);
    border-radius: 12px;
    background: var(--color-gray-1);
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: clamp(1rem, 3vw, 1.5rem);
    min-height: clamp(180px, 25vw, 200px);
  }

  .upload-area:hover,
  .upload-area.dragover {
    border-color: var(--color-purple);
    background: var(--color-purple-light);
  }

  .upload-area svg {
    color: var(--color-purple);
    margin-bottom: var(--space-m);
  }

  .upload-area p {
    margin: var(--space-xs) 0;
    color: var(--color-gray-7);
  }

  .upload-hint {
    font-size: var(--text-sm);
    color: var(--color-gray-5);
  }

  .image-preview-container {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: var(--space-l);
  }

  .image-preview-container img {
    width: 100%;
    max-height: 600px;
    object-fit: contain;
    background: var(--color-gray-1);
  }

  .btn-remove {
    position: absolute;
    top: var(--space-m);
    right: var(--space-m);
    background: rgba(0, 0, 0, 0.7);
    color: var(--color-white);
    border: none;
    padding: var(--space-s) var(--space-m);
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
  }

  .btn-remove:hover {
    background: rgba(0, 0, 0, 0.9);
  }

  /* Metadata Grid */
  .metadata-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(100%, 250px), 1fr));
    gap: clamp(0.75rem, 2vw, 1rem);
  }

  .form-group label {
    display: block;
    font-weight: 600;
    margin-bottom: clamp(0.375rem, 1vw, 0.5rem);
    color: var(--color-gray-8);
    font-size: clamp(0.875rem, 2vw, 1rem);
  }

  .optional {
    font-weight: 400;
    color: var(--color-gray-5);
    font-size: clamp(0.75rem, 1.5vw, 0.875rem);
  }

  .form-group input,
  .form-group textarea {
    width: 100%;
    padding: clamp(0.5rem, 2vw, 0.75rem);
    border: 2px solid var(--color-gray-3);
    border-radius: 6px;
    font-family: var(--font-body);
    font-size: clamp(0.875rem, 2vw, 1rem);
  }

  .form-group textarea {
    resize: vertical;
    min-height: 120px;
    line-height: 1.6;
  }

  .form-group input:focus,
  .form-group textarea:focus {
    outline: none;
    border-color: var(--color-purple);
  }

  /* Mode Selector */
  .mode-selector {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(min(100%, 280px), 1fr));
    gap: clamp(0.75rem, 2vw, 1rem);
  }

  .mode-card {
    position: relative;
    display: block;
    cursor: pointer;
  }

  .mode-card input[type="radio"] {
    position: absolute;
    opacity: 0;
  }

  .mode-content {
    padding: clamp(1rem, 3vw, 1.5rem);
    border: 0.5px solid var(--color-purple);
    border-radius: 8px;
    transition: all 0.2s ease;
    background: var(--color-white);
    height: 100%;
    min-height: 120px;
  }

  .mode-card input:checked + .mode-content {
    border-width: 2px;
    border-color: var(--color-purple);
    background: var(--color-purple-light);
  }

  .mode-card:hover .mode-content {
    border-color: var(--color-purple);
  }

  .mode-content h3 {
    font-family: var(--font-heading);
    font-size: var(--text-lg);
    color: var(--color-purple);
    margin: 0 0 var(--space-xs);
  }

  .mode-phase {
    font-size: var(--text-sm);
    color: var(--color-gray-6);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin: 0 0 var(--space-s);
  }

  .mode-description {
    font-size: var(--text-sm);
    color: var(--color-gray-7);
    margin: 0;
    line-height: 1.5;
  }

  /* Action Buttons */
  .form-actions {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: clamp(0.75rem, 2vw, 1rem);
    margin-top: clamp(2rem, 5vw, 3rem);
  }

  .btn-primary,
  .btn-secondary {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: clamp(0.5rem, 1.5vw, 0.75rem);
    padding: clamp(0.75rem, 2.5vw, 1rem) clamp(1.5rem, 4vw, 3rem);
    border: none;
    border-radius: 8px;
    font-family: var(--font-heading);
    font-size: clamp(0.875rem, 2vw, 1rem);
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    min-height: 44px;
  }

  .btn-primary {
    background: var(--color-purple);
    color: var(--color-white);
  }

  .btn-primary:hover:not(:disabled) {
    background: var(--color-purple-dark);
    box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
  }

  .btn-primary:disabled {
    background: var(--color-gray-4);
    cursor: not-allowed;
  }

  .btn-secondary {
    background: var(--color-white);
    color: var(--color-purple);
    border: 2px solid var(--color-purple);
  }

  .btn-secondary:hover {
    background: var(--color-purple-light);
  }

  /* Loading State */
  .loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: var(--space-3xl);
    text-align: center;
  }

  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 4px solid var(--color-gray-3);
    border-top-color: var(--color-purple);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: var(--space-xl);
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .loading-state h2 {
    font-family: var(--font-heading);
    color: var(--color-purple);
    margin-bottom: var(--space-m);
  }

  .loading-state p {
    color: var(--color-gray-6);
  }

  /* Results Panel */
  .results-panel {
    padding: var(--space-xl);
  }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space-l);
    border-bottom: 2px solid var(--color-gray-2);
  }

  .results-header h2 {
    font-family: var(--font-display);
    font-size: var(--text-3xl);
    color: var(--color-purple);
    margin: 0;
  }

  .results-actions {
    display: flex;
    gap: var(--space-m);
    flex-wrap: wrap;
  }

  .results-content {
    font-family: var(--font-body);
    line-height: 1.8;
    color: var(--color-gray-8);
  }

  @media (max-width: 768px) {
    .page-header h1 {
      font-size: var(--text-3xl);
    }

    .mode-selector {
      grid-template-columns: 1fr;
    }

    .metadata-grid {
      grid-template-columns: 1fr;
    }

    .results-header {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-m);
    }

    .results-actions {
      flex-direction: column;
      width: 100%;
    }

    .btn-secondary {
      width: 100%;
      justify-content: center;
    }
  }
</style>
